---
// FRONTMATTER: Esta sección es como el controller de Rails
// Aquí va la lógica de JavaScript que se ejecuta en BUILD TIME (no en el browser)
// Props son como los parámetros que pasas a un partial

// Importamos el CSS aquí - Astro lo procesa correctamente
import '../styles/global.css';

interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Matias Fernandez - Web Developer based in Japan" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <title>{title}</title>
  </head>

  <body class="bg-zinc-950 text-zinc-200 antialiased overflow-x-hidden">
    <!--
      antialiased: Suaviza las fuentes (se ve más profesional)
      bg-zinc-950: Fondo casi negro pero con un toque cálido
      text-zinc-100: Texto casi blanco

      ¿Por qué zinc en lugar de gray?
      - zinc tiene tonos más neutrales/cálidos
      - gray puede verse "azulado" en algunos monitores
      - zinc es más moderno para portfolios tech
    -->

    <slot />
    <!--
      <slot /> es como <%= yield %> en Rails
      Aquí se inserta el contenido de cada página
    -->

    <!--
      JAVASCRIPT VANILLA
      En Astro, los scripts con la etiqueta <script> se ejecutan en el browser
      (a diferencia del frontmatter que se ejecuta en build time)

      Este es el equivalente a donde pondrías tu Stimulus controller,
      pero más simple porque es vanilla JS
    -->
    <script>
      // ================================
      // HEADER SCROLL EFFECT
      // ================================
      // Añade efecto glassmorphism al header cuando el usuario hace scroll
      const header = document.getElementById('header');

      const handleScroll = () => {
        if (window.scrollY > 50) {
          header?.classList.add('header-scrolled');
        } else {
          header?.classList.remove('header-scrolled');
        }
      };

      window.addEventListener('scroll', handleScroll, { passive: true });
      // passive: true mejora el performance del scroll

      // ================================
      // INTERSECTION OBSERVER (Animaciones on scroll)
      // ================================
      // Esto detecta cuando un elemento entra en el viewport
      // Similar a lo que harías con un library como AOS pero sin dependencias

      const observerOptions = {
        root: null, // viewport
        rootMargin: '0px',
        threshold: 0.1 // Se activa cuando 10% del elemento es visible
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            observer.unobserve(entry.target); // Solo anima una vez
          }
        });
      }, observerOptions);

      // Observamos todos los elementos con la clase .animate-on-scroll
      document.querySelectorAll('.animate-on-scroll').forEach((el) => {
        observer.observe(el);
      });

      // ================================
      // SMOOTH SCROLL (solo para clicks en anchor links)
      // ================================
      // Esto evita el "salto" al hacer refresh que causa scroll-smooth en el html
      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener('click', (e) => {
          e.preventDefault();
          const targetId = anchor.getAttribute('href');
          const target = document.querySelector(targetId);
          if (target) {
            target.scrollIntoView({ behavior: 'smooth' });
          }
        });
      });
    </script>
  </body>
</html>
